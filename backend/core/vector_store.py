import os
import logging
from typing import List, Dict, Optional, Any
from dataclasses import dataclass

logger = logging.getLogger(__name__)

# VectorStore interface compatible with multiple backends
# For demonstration, we'll implement using Chroma backend

try:
    import chromadb
    from chromadb.config import Settings as ChromaSettings
    from chromadb.utils import embedding_functions
except ImportError:
    chromadb = None
    logger.warning("Chroma client library is not installed. VectorStore won't work.")

@dataclass
class VectorStoreStats:
    num_documents: int
    num_chunks: int
    vector_store_name: str


class VectorStore:
    def __init__(
        self,
        collection_name: str = "qa_agent_vectors",
        persist_directory: str = "data/vectorstore",
    ):
        if chromadb is None:
            raise ImportError("chromadb library is required but not installed.")

        os.makedirs(persist_directory, exist_ok=True)

        self.collection_name = collection_name
        self.persist_directory = persist_directory

        # Initialize chroma client with persistence
        self.client = chromadb.Client(
            ChromaSettings(
                persist_directory=self.persist_directory,
                chroma_db_impl="duckdb+parquet",
            )
        )

        # Create or get collection
        try:
            self.collection = self.client.get_collection(self.collection_name)
            logger.info(f"Using existing chroma collection: {self.collection_name}")
        except Exception:
            self.collection = self.client.create_collection(self.collection_name)
            logger.info(f"Created new chroma collection: {self.collection_name}")

    async def add_vector(self, embedding: List[float], metadata: Dict[str, Any]) -> None:
        """
        Add a single vector with metadata to the vector store.
        The vector ID will be autogenerated UUID based on metadata or internal logic.
        """
        try:
            # Compose an id string, ensure uniqueness (e.g. document_id + chunk_index)
            _id = f"{metadata.get('document_id', 'doc')}_{metadata.get('chunk_index', 0)}"
            self.collection.add(
                embeddings=[embedding],
                metadatas=[metadata],
                ids=[_id],
            )
            # Persist after adding
            self.client.persist()
        except Exception as exc:
            logger.error(f"Failed to add vector ID {_id}: {exc}")
            raise

    async def similarity_search(
        self, query_embedding: List[float], top_k: int = 5
    ) -> List[Dict[str, Any]]:
        """
        Search the vector store by similarity, returning top_k results with metadata and distance.
        """
        try:
            results = self.collection.query(
                query_embeddings=[query_embedding],
                n_results=top_k,
                include=["metadatas", "distances", "documents"],
            )
        except Exception as exc:
            logger.error(f"Vector store query failed: {exc}")
            raise RuntimeError(f"Vector store query error: {exc}")

        hits = []
        for meta, dist, doc in zip(
            results["metadatas"][0], results["distances"][0], results["documents"][0]
        ):
            hits.append({"metadata": meta, "distance": dist, "document": doc})
        return hits

    def count_documents(self) -> int:
        """
        Return total number of unique documents indexed in the collection.
        """
        try:
            metadatas = self.collection.get(include=["metadatas"])["metadatas"]
            # Extract unique document_ids from metadatas
            doc_ids = {md.get("document_id") for md in metadatas}
            return len(doc_ids)
        except Exception as exc:
            logger.error(f"Failed to count documents: {exc}")
            return 0

    def count_vectors(self) -> int:
        """
        Return total number of vector chunks in the collection.
        """
        try:
            count = self.collection.count()
            return count
        except Exception as exc:
            logger.error(f"Failed to count vectors: {exc}")
            return 0

    def clear_collection(self) -> None:
        """
        Deletes all vectors and metadata inside the collection.
        """
        try:
            self.collection.delete(where={})
            self.client.persist()
            logger.info(f"Cleared all data from collection {self.collection_name}")
        except Exception as exc:
            logger.error(f"Failed to clear collection: {exc}")
            raise

